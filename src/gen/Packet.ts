// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: Packet.proto

/* eslint-disable */
import { Command } from "./Command";
import { CommandResponse } from "./CommandResponse";
import { Telemetry } from "./Telemetry";

export const protobufPackage = "HPRC";

export interface BeginPacketChunks {
  numPacketsToBeSent: number;
  numBytesToBeSent: number;
}

export interface EndPacketChunks {
  numPacketsSent: number;
  numBytesSent: number;
}

export interface Packet {
  Message?:
    | { $case: "telemetry"; telemetry: Telemetry }
    | { $case: "command"; command: Command }
    | { $case: "commandResponse"; commandResponse: CommandResponse }
    | { $case: "beginPacketChunks"; beginPacketChunks: BeginPacketChunks }
    | { $case: "endPacketChunks"; endPacketChunks: EndPacketChunks }
    | undefined;
}

function createBaseBeginPacketChunks(): BeginPacketChunks {
  return { numPacketsToBeSent: 0, numBytesToBeSent: 0 };
}

export const BeginPacketChunks: MessageFns<BeginPacketChunks> = {
  fromJSON(object: any): BeginPacketChunks {
    return {
      numPacketsToBeSent: isSet(object.numPacketsToBeSent) ? globalThis.Number(object.numPacketsToBeSent) : 0,
      numBytesToBeSent: isSet(object.numBytesToBeSent) ? globalThis.Number(object.numBytesToBeSent) : 0,
    };
  },

  toJSON(message: BeginPacketChunks): unknown {
    const obj: any = {};
    if (message.numPacketsToBeSent !== 0) {
      obj.numPacketsToBeSent = Math.round(message.numPacketsToBeSent);
    }
    if (message.numBytesToBeSent !== 0) {
      obj.numBytesToBeSent = Math.round(message.numBytesToBeSent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BeginPacketChunks>, I>>(base?: I): BeginPacketChunks {
    return BeginPacketChunks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BeginPacketChunks>, I>>(object: I): BeginPacketChunks {
    const message = createBaseBeginPacketChunks();
    message.numPacketsToBeSent = object.numPacketsToBeSent ?? 0;
    message.numBytesToBeSent = object.numBytesToBeSent ?? 0;
    return message;
  },
};

function createBaseEndPacketChunks(): EndPacketChunks {
  return { numPacketsSent: 0, numBytesSent: 0 };
}

export const EndPacketChunks: MessageFns<EndPacketChunks> = {
  fromJSON(object: any): EndPacketChunks {
    return {
      numPacketsSent: isSet(object.numPacketsSent) ? globalThis.Number(object.numPacketsSent) : 0,
      numBytesSent: isSet(object.numBytesSent) ? globalThis.Number(object.numBytesSent) : 0,
    };
  },

  toJSON(message: EndPacketChunks): unknown {
    const obj: any = {};
    if (message.numPacketsSent !== 0) {
      obj.numPacketsSent = Math.round(message.numPacketsSent);
    }
    if (message.numBytesSent !== 0) {
      obj.numBytesSent = Math.round(message.numBytesSent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndPacketChunks>, I>>(base?: I): EndPacketChunks {
    return EndPacketChunks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndPacketChunks>, I>>(object: I): EndPacketChunks {
    const message = createBaseEndPacketChunks();
    message.numPacketsSent = object.numPacketsSent ?? 0;
    message.numBytesSent = object.numBytesSent ?? 0;
    return message;
  },
};

function createBasePacket(): Packet {
  return { Message: undefined };
}

export const Packet: MessageFns<Packet> = {
  fromJSON(object: any): Packet {
    return {
      Message: isSet(object.telemetry)
        ? { $case: "telemetry", telemetry: Telemetry.fromJSON(object.telemetry) }
        : isSet(object.command)
        ? { $case: "command", command: Command.fromJSON(object.command) }
        : isSet(object.commandResponse)
        ? { $case: "commandResponse", commandResponse: CommandResponse.fromJSON(object.commandResponse) }
        : isSet(object.beginPacketChunks)
        ? { $case: "beginPacketChunks", beginPacketChunks: BeginPacketChunks.fromJSON(object.beginPacketChunks) }
        : isSet(object.endPacketChunks)
        ? { $case: "endPacketChunks", endPacketChunks: EndPacketChunks.fromJSON(object.endPacketChunks) }
        : undefined,
    };
  },

  toJSON(message: Packet): unknown {
    const obj: any = {};
    if (message.Message?.$case === "telemetry") {
      obj.telemetry = Telemetry.toJSON(message.Message.telemetry);
    } else if (message.Message?.$case === "command") {
      obj.command = Command.toJSON(message.Message.command);
    } else if (message.Message?.$case === "commandResponse") {
      obj.commandResponse = CommandResponse.toJSON(message.Message.commandResponse);
    } else if (message.Message?.$case === "beginPacketChunks") {
      obj.beginPacketChunks = BeginPacketChunks.toJSON(message.Message.beginPacketChunks);
    } else if (message.Message?.$case === "endPacketChunks") {
      obj.endPacketChunks = EndPacketChunks.toJSON(message.Message.endPacketChunks);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Packet>, I>>(base?: I): Packet {
    return Packet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Packet>, I>>(object: I): Packet {
    const message = createBasePacket();
    switch (object.Message?.$case) {
      case "telemetry": {
        if (object.Message?.telemetry !== undefined && object.Message?.telemetry !== null) {
          message.Message = { $case: "telemetry", telemetry: Telemetry.fromPartial(object.Message.telemetry) };
        }
        break;
      }
      case "command": {
        if (object.Message?.command !== undefined && object.Message?.command !== null) {
          message.Message = { $case: "command", command: Command.fromPartial(object.Message.command) };
        }
        break;
      }
      case "commandResponse": {
        if (object.Message?.commandResponse !== undefined && object.Message?.commandResponse !== null) {
          message.Message = {
            $case: "commandResponse",
            commandResponse: CommandResponse.fromPartial(object.Message.commandResponse),
          };
        }
        break;
      }
      case "beginPacketChunks": {
        if (object.Message?.beginPacketChunks !== undefined && object.Message?.beginPacketChunks !== null) {
          message.Message = {
            $case: "beginPacketChunks",
            beginPacketChunks: BeginPacketChunks.fromPartial(object.Message.beginPacketChunks),
          };
        }
        break;
      }
      case "endPacketChunks": {
        if (object.Message?.endPacketChunks !== undefined && object.Message?.endPacketChunks !== null) {
          message.Message = {
            $case: "endPacketChunks",
            endPacketChunks: EndPacketChunks.fromPartial(object.Message.endPacketChunks),
          };
        }
        break;
      }
    }
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
